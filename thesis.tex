\documentclass{article}

\begin{document}
 
\title{Distributed applications in an scalable environment}
\author{Simon Norberg - norberg.simon@gmail.com\\
        Filip Andersson - flpandersson@gmail.com }
\date{\today}
\maketitle
 
%\begin{abstract}
%TODO
%\end{abstract}
 
\section{Introduction}

Distribution and scalability is becoming an important issue in todays
application development \cite{rellermeyer2007services}.
The need for an application to scale between a few users up to several millions 
on very short notice gives developers limited time to modify and/or redesign 
the application, so having an already scalable system has a lot of benefits. 
If a system looses its ability to scale, and thereby cannot support more users, 
it may quickly loose its target audience to a competitor. Furthermore, being able 
to modify and update parts of the system separately, rather than everything at 
once, makes application maintenance significantly easier and downtime minimal 
in production systems.

\subsection{Background}

A scalable system is a system that is flexible and adaptive to changing
conditions, such as an increase in system load, new system components etc., and
that can be economically deployed in many configurations, small as well as
large \cite{jogalekar2000evaluating}. The scalability of a system depends on
how well it can exploit functional modularity, structural regularity and
hierarchy \cite{lipson2007principles}.

To make a system modular it can be implemented using \emph{OSGi} and
\emph{R-OSGi} \cite{rellermeyer2007services}. By using these frameworks one can
update and add components to ones system at will, and manage different
components without having to bring down the entire system. When deployed,
R-OSGi can be used to turn the application into a distributed application by
indicating where the different modules should be deployed
\cite{rellermeyer2007r}, which can be used to greatly simplify development of
distributed systems.

\emph{Distributed Computing}, perhaps more known as \emph{Cloud Computing}, is becoming a
more and more common approach to software development. The basic concept of
distributed computing is to make different services available in the so called
'cloud', which means that these services are reachable from anywhere one has
internet access. These services can, for example, be things like e-mail,
document editing, social networks and much more. The fact that these services
are so widely distributed places high demands on the number of users that can
be supported. These demands can be accommodated by simply making sure the
systems have a large amount of resources from the start, or adding resources
from time to time. However, if there's less users on the system than it has
capacity for, this approach quickly becomes expensive due to a lot of unused
resources. This problem can be solved by making the system scalable, i.e. that
it uses resources in proportion to the number of current users. If the user
base drops, it will use less resources, and when more people are using the
system it will use more. By making a system scalable, one makes it able to
adapt to changing conditions and environments, which is important since a
system is generally developed to run over a relatively large period of time,
during which a lot of things may rapidly change \cite{van1998software}
\cite{caruso1997toward}.

To promote scalability in a distributed setting one can use, for example, a
\emph{Message Passing Interface (MPI)} which enables message passing between
parallel programs running on computer clusters \cite{gropp1996high}. By using
this, the system can enable additional resources when needed by sending
inter-process messages.
 
\subsection{Goals} 

What we intend to investigate is what needs to be considered
when developing a scalable distributed system, and to what cost these features
comes at. We believe that while the cost of these features may initially be
higher, the cost of maintainability is lower. We hope that the outcome of our
research will be useful for people trying to determine whether or not to strive
towards implementing a scalable distributed system from the start, rather than
incrementally increasing system capacity during the system's lifetime.

\newpage

\section{Research questions}
\begin{itemize}
\item{RQ1: How do one successfully develop a scalable distributed system? Which
factors needs to be considered, and how does one achieve these? Without knowing
what needs to be done, developing a high-grade scalable system may be
difficult, and cost alot of extra time.} 

\item{RQ1.1: Which technologies, libraries and software can one use to achieve
high-grade scalability? Not all technologies etc. support a high level of
scalability, and knowing the difference between the ones who do and the ones
who do not can save a lot of expenses.}

\item{RQ2: Which extra costs do the development of scalable systems lead to?} 
\item{RQ2.1: When done in advance?} 
\item{RQ2.2: When done after the initial development?} 

\item{RQ3: Which kind of systems can benefit from having high-grade scalability?
It is important to know if a certain system actually benefits from being highly
scalable, and if so, how much. If the benefits are relatively small, there 
might be cheaper ways of developing it.}

\end{itemize}

\section{Research methodology}
We will be using a Literature Review and a Post-mortem analysis to conduct our 
research. 

\subsection{Literature review design}
We will be searching for literature for our review mainly on Google Scholar and
on BTH's article database Elin. The keywords we will be using while searching 
will be focused on terms related to distributed systems and scalability.

The research started with the keywords scalable and distributed systems,
from there we read article that looked promising first by just looking on
the topic and if it looked relevant for our thesis, we took a closer look
at the abstract. After reading the abstract we made a decision if the paper
was in the scope of our project and if it was that we selected it. And used
terminology found in that paper to find further papers on which the same 
process was used. 
\newline

List of keywords:
\begin{itemize}
\item{scalable systems}
\item{python parallel}
\item{mpi}
\item{Distributed systems AND scalable design}
\item{Distributed environments services osgi}
\item{Scalable distribution AND software}
\item{Scalable development AND cost}
\item{Scalability AND distributed systems}
\item{Distributed Applications AND Software Modularization}
\end{itemize}

%fixme: still needed?
The relevance of the literature will be determined by reading the abstract and
possibly the introduction. If the literature seems to match our needs, we will
then study it further, if not it will be dismissed.

\subsection{Post-mortem analysis design}

%fixme clerify 
\subsubsection{Project}
We will not actually be collecting any data from the project, but rather
utilize the experience of writing distributed and scalable software which we
gained during the project as a starting point for our post-mortem analysis. We
are using OSGi \cite{marples2001open} as a main component in our distributed
system, and we have concurrent requests to our backend API and our database.
Since our system is both distributed and places high demands on scalability, we
feel that we have at least some experience in the area.

\subsubsection{MPI}
We will also study how a more classical and well tested approach to writing
scalable distributed systems with MPI \cite{gropp1996high}. MPI have easy
to use python bindings \cite{miller2002pympi} \cite{millerparallel} we will be
using to write test programs that test the capabilities of MPI and compare the
performance and cost to develop.
We will be measuring:
\begin{itemize}
\item Time to develop
\item Lines of code
\item How easy the code is to understand
\item How easy it is to extend the program
\item Performance - How fast do the application run
\item Scalability - how well do it scale when adding more resources
\item Performance when using only one node, eg. overhead for MPI
\end{itemize}
 


\bibliographystyle{unsrt}
\bibliography{reference}
\end{document}
